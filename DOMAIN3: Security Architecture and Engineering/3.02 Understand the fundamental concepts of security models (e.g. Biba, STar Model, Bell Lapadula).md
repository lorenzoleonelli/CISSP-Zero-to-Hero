## 3.2 Understand the fundamental concepts of security models (e.g. Biba, STar Model, Bell Lapadula) ##

Security models provide structured frameworks to enforce security policies and ensure that systems operate securely. These models define rules for access control, information flow, and system security. 

A **state machine** model ensures that a system is always in a secure state. Think of a state as a snapshot of a system at a specific moment, including user permissions, data access levels, and active processes.
For a system to be considered secure, every transition between states (such as logging in, opening a file, or executing a program) must maintain security properties. This means that if a system starts in a secure state and follows the defined rules, it will always remain secure.

These are the main components of a state machine model:
| Component                 | Description                                                                   |
|--------------------------|-------------------------------------------------------------------------------|
| **States**                | The various conditions or modes a system can be in (e.g., logged in, locked). |
| **Events/Input**          | Triggers that cause state transitions (e.g., a login attempt).                |
| **Transitions**           | Rules that move the system from one state to another.                         |
| **Initial State**         | The default starting point (e.g., system off or user logged out).             |
| **Final/Accepting State** | End state or condition where a process completes.                             |

In the following you can find a login system which is an example of a state machine model:

```mermaid
stateDiagram-v2
    [*] --> LoggedOut
    LoggedOut --> LoggingIn: User enters credentials
    LoggingIn --> LoggedIn: Credentials valid
    LoggingIn --> LoggedOut: Credentials invalid
    LoggedIn --> LoggedOut: User logs out

    classDef center fill:#ffffff,color:#000000,stroke:#000000,stroke-width:1px,font-weight:bold
    classDef node fill:#e0e0e0,color:#000000,stroke:#000000,stroke-width:1px
```

The **lattice** model is used in mandatory access control (MAC) systems, where data and users are assigned security labels. These labels determine who can access what, using a mathematical structure called a lattice.
The main idea is simple:

- Every user and object (files, databases, etc.) has a classification level (e.g., Top Secret, Secret, Confidential, Unclassified).

- Users can only access information at their level or lower (e.g., a Secret user can access Confidential data but not Top Secret data).

For example, in military organizations, a general with Top Secret clearance can access all classified information, while a soldier with Confidential clearance cannot see Secret or Top Secret data.

These are the main components of a state machine model:
| Component             | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| **Subjects**          | Active entities (e.g., users, processes) requesting access to objects.     |
| **Objects**           | Passive entities (e.g., files, databases) being accessed.                  |
| **Security Labels**   | Labels (e.g., Top Secret, Secret, Confidential) assigned to subjects/objects. |
| **Security Lattice**  | A structure defining the dominance relationship among labels.              |
| **Dominance Relation**| A rule that defines when a subject can access an object based on labels.   |
| **Access Rules**      | Determines if a subject can read/write an object based on the lattice.     |


```mermaid
stateDiagram-v2
    [*] --> RequestAccess: Subject requests access to Object
    RequestAccess --> CheckLabels: Compare subject and object labels
    CheckLabels --> AccessGranted: If subject dominates object (read) or object dominates subject (write)
    CheckLabels --> AccessDenied: If dominance rule is not satisfied


    classDef center fill:#ffffff,color:#000000,stroke:#000000,stroke-width:1px,font-weight:bold
    classDef node fill:#e0e0e0,color:#000000,stroke:#000000,stroke-width:1px
```

**Information Flow** Models ensure that data flows in a secure manner, preventing leaks or unauthorized access. They focus on how information moves within a system rather than just access permissions.

Bell-LaPadula Model (Confidentiality Focused) → Prevents unauthorized reading of higher-classified data (No Read Up) and unauthorized writing to lower-classified data (No Write Down).

Biba Model (Integrity Focused) → Prevents users from modifying higher-integrity data (No Write Up) and from reading lower-integrity data (No Read Down).

For example e financial system using the Biba Model would prevent an intern from modifying critical accounting records, ensuring only senior accountants can make changes.

These are the main components of an information flow model:
| Component             | Description                                                                 |
|----------------------|-----------------------------------------------------------------------------|
| **Subjects**          | Active entities (e.g., users, programs) that send or receive information.  |
| **Objects**           | Passive entities (e.g., files, databases) involved in information exchange. |
| **Information Flow**  | The movement or transfer of data between subjects and/or objects.           |
| **Flow Policy**       | Rules that determine allowed and disallowed data flows based on labels or levels. |
| **Security Labels**   | Classifications assigned to subjects and objects (e.g., Confidential, Public). |
| **Channels**          | Logical paths or mechanisms used to transfer data.                          |
| **Direction of Flow** | Indicates whether flow is read, write, or communication between components. |

```mermaid
stateDiagram-v2
    [*] --> FlowRequest: Subject attempts to send or receive information
    FlowRequest --> CheckPolicy: System checks flow against security policy
    CheckPolicy --> AllowedFlow: Flow is permitted under current policy
    CheckPolicy --> BlockedFlow: Flow is denied to prevent a policy violation
    AllowedFlow --> [*]
    BlockedFlow --> [*]

    classDef center fill:#ffffff,color:#000000,stroke:#000000,stroke-width:1px,font-weight:bold
    classDef node fill:#e0e0e0,color:#000000,stroke:#000000,stroke-width:1px
```
