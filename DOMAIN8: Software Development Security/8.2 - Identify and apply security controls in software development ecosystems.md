## 8.2.1 Programming languages ##

Programming languages are the DNA of software. If you’re assessing application security, performing static code analysis, writing scripts for automation, or reviewing source code for backdoors, it pays to know the basics. 
All programming languages are essentially tools to tell machines what to do, using logic and structure a machine can execute. But the variety is where things get interesting.

**High-level languages** like Python, Java, or C# prioritize developer efficiency and readability. 
**Low-level languages** like Assembly or even C expose memory management and hardware interaction, making them favorites for performance-intensive or system-level applications — and unfortunately, also for many exploits.

Take C, for instance. It has no built-in memory protection, which is why buffer overflows are rampant in C-based software. An attacker can exploit this to inject malicious code into memory and hijack execution. This alone makes C and C++ programs high-priority targets for secure code reviews. Java, on the other hand, runs in a virtual machine, which creates a safer sandbox, but it’s not invulnerable. Deserialization attacks and misused class loaders are real threats. Python is great for rapid development and often used for scripting in penetration testing tools like those in Kali Linux, but it can become dangerous if developers rely on unsafe methods like eval() or use outdated libraries.

:necktie: Security is about understanding where the weaknesses can hide — and many of them are born in the code itself.

**Input validation** is the most basic yet crucial step to prevent injection attacks. A simple SQL query embedded in PHP or Python can be weaponized if the input is not sanitized. Suddenly, a user becomes an attacker, and your database is spilling secrets. Understanding what input sanitization looks like in different languages helps you catch insecure patterns faster. If you’re reviewing a Python-based web app and you see string concatenation used to build SQL queries, your alarm bells should go off. In contrast, seeing a prepared statement or an ORM (object-relational mapping) function being used is a good sign. Similarly, language features matter when thinking about cross-site scripting (XSS) or cross-site request forgery (CSRF). JavaScript is powerful but dangerous in the wrong hands. Because it runs in the browser, attackers love using it to hijack sessions or exfiltrate data from forms or cookies. The security model of JavaScript is tightly coupled with the browser’s same-origin policy and that bypassing it through DOM manipulation or injecting script tags is how attackers compromise the client side. So when someone says "JavaScript is just frontend," you now know it’s actually a prime attack vector in the browser world.

Think also about **compiled versus interpreted languages**. C, C++, and Go are compiled — meaning they are turned into machine code before execution, which makes them faster but harder to debug at runtime. Interpreted languages like Python, Ruby, or JavaScript are run line by line, which makes them easier to change on the fly — but also more exposed during execution. Attackers can tamper with scripts, inject runtime logic, or exploit debug modes if the environment isn’t properly locked down. This is where secure deployment and language-specific hardening become essential. 

Languages also differ in how they **manage memory**. For example, C and C++ developers have to allocate and free memory manually using malloc() and free(), and that’s a double-edged sword. It gives control, but mistakes open doors to use-after-free or heap overflow vulnerabilities. In contrast, Java, Python, and C# use garbage collection, which reduces the risk of memory leaks and corruption but doesn’t eliminate all risks. A poorly designed loop or unclosed resource can still exhaust memory and trigger a denial-of-service condition.

Then you have languages used in secure **scripting and automation**. Bash, PowerShell, Python — these are the tools of the trade for both defenders and attackers. A red team might use Python to automate phishing payload delivery or exploit chaining. A blue team might write a PowerShell script to audit AD permissions or rotate service account credentials. Knowing how scripts can be abused means you can write better detection rules. Ever reviewed a PowerShell script and found it was obfuscated using Base64 or broken into chunks to bypass antivirus? That’s how real-world attacks are hidden. Being familiar with these patterns helps you spot trouble fast. 

We should also understand the idea of **sandboxing** and **permissions**. Mobile apps written in Swift (iOS) or Java/Kotlin (Android) run in permission-controlled environments. But misconfigured permissions can allow apps to access more than they should. A flashlight app that accesses your microphone? Red flag. 

### Open Questions ###

1. Why is it important for security professionals to understand the distinction between compiled and interpreted languages when assessing software security?

<details> <summary>Show answer</summary> Understanding whether a language is compiled or interpreted affects how software is deployed, secured, and attacked. Compiled languages may be less transparent but prone to lower-level memory issues, while interpreted languages are more dynamic and easier to reverse-engineer, making runtime inspection and exploitation more feasible. </details>

2. How does manual memory management in languages like C create potential security risks?

<details> <summary>Show answer</summary> Languages like C require developers to manage memory manually, which opens the door to vulnerabilities such as buffer overflows, heap corruption, and dangling pointers. These flaws are often exploited in remote code execution and privilege escalation attacks. </details>

3. What characteristics of scripting languages like Python and PowerShell make them appealing to both system administrators and attackers?

<details> <summary>Show answer</summary> Python and PowerShell offer rapid scripting capabilities, access to system-level commands, and integration with automation tools. Unfortunately, their flexibility and power also allow attackers to craft payloads, automate exploitation, and bypass traditional defenses using obfuscation and in-memory execution. </details>

4. What are some common insecure coding practices associated with JavaScript that a CISSP should be able to identify?

<details> <summary>Show answer</summary> JavaScript vulnerabilities often stem from poor input validation, unsafe DOM manipulation, and use of functions like eval() or innerHTML. These can lead to cross-site scripting (XSS), data leakage, and session hijacking, especially when web applications don't apply secure coding practices. </details>

5. Why should a CISSP be concerned about the use of third-party libraries in modern programming environments?

<details> <summary>Show answer</summary> Third-party libraries increase development speed but also expand the attack surface. Vulnerabilities or malicious code in libraries can compromise the entire application. CISSP professionals must promote the use of vetted components, dependency management tools, and software composition analysis to mitigate this risk. </details>

---

## 8.2.2 Libraries ##

